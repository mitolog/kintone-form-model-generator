const dummyBaseUrl = "https://dummy-base-url.local";
process.env.KINTONE_BASE_URL = dummyBaseUrl;
process.env.KINTONE_USERNAME = "dummy-user";
process.env.KINTONE_PASSWORD = "dummy-pw";

import { generate } from "./generate";
import * as client from "./util/client";
import { createClientConfig, ClientConfig } from "./util/client";
import { Config, createConfig } from "./util/config";
import getAppsResponse from "./__tests__/get-apps-response.json";
import getNameDuplicatedAppsResponse from "./__tests__/get-name-duplicated-apps-response.json";
import getFormFieldsResponse from "./__tests__/get-form-fields-response.json";
import p from "../package.json";

describe("generate", () => {
  describe("normal case", () => {
    let config: Config;
    let clientConfig: ClientConfig;
    beforeEach(() => {
      config = createConfig();
      clientConfig = createClientConfig();
      jest.spyOn(client, "Client").mockImplementationOnce(() => {
        return {
          getApps: () => getAppsResponse.apps,
          getFormFields: () => getFormFieldsResponse,
        } as unknown as client.Client;
      });
    });

    test("regression test", async () => {
      const result = await generate({
        params: {},
        config,
        clientConfig,
      });

      expect(result).toBe(actual);
    });

    test("if modelNaming is appName", async () => {
      config.modelNaming = "appName";

      const result = await generate({
        params: {},
        config,
        clientConfig,
      });

      expect(result).toContain("interface Kintone入力項目テストアプリRecord");
    });

    test("modelNameMapping", async () => {
      config.modelNameMapping = {
        "54": "CustomName",
      };

      const result = await generate({
        params: {},
        config,
        clientConfig,
      });

      expect(result).toContain("interface KintoneCustomNameRecord");
    });

    test("if modelNamePrefix is empty", async () => {
      config.modelNamePrefix = "";

      const result = await generate({
        params: {},
        config,
        clientConfig,
      });

      expect(result).toContain("interface App54Record");
    });

    test("if modelNameSuffix is empty", async () => {
      config.modelNameSuffix = "";

      const result = await generate({
        params: {},
        config,
        clientConfig,
      });

      expect(result).toContain("interface KintoneApp54");
    });
  });

  describe("error case (not found)", () => {
    let config: Config;
    let clientConfig: ClientConfig;
    beforeEach(() => {
      config = createConfig();
      config.modelNaming = "appName";

      clientConfig = createClientConfig();
      jest.spyOn(client, "Client").mockImplementationOnce(() => {
        return {
          getApps: () => [],
        } as unknown as client.Client;
      });
    });

    test("if appId is not specified", async () => {
      const result = generate({
        params: {},
        config,
        clientConfig,
      });

      await expect(result).rejects.toThrow();
    });

    test("if appId is not found", async () => {
      const result = generate({
        params: {
          appIds: ["1"],
        },
        config,
        clientConfig,
      });

      await expect(result).rejects.toThrow();
    });
  });

  describe("error case (duplicate)", () => {
    let config: Config;
    let clientConfig: ClientConfig;
    beforeEach(() => {
      config = createConfig();
      config.modelNaming = "appName";

      clientConfig = createClientConfig();
      jest.spyOn(client, "Client").mockImplementationOnce(() => {
        return {
          getApps: () => getNameDuplicatedAppsResponse.apps,
          getFormFields: () => getFormFieldsResponse,
        } as unknown as client.Client;
      });
    });

    test("if modelNamingDuplicationStrategy is error", async () => {
      config.modelNamingDuplicationStrategy = "error";

      const result = generate({
        params: {},
        config,
        clientConfig,
      });

      await expect(result).rejects.toThrow();
    });

    test("if modelNamingDuplicationStrategy is skip", async () => {
      config.modelNamingDuplicationStrategy = "skip";

      const result = await generate({
        params: {},
        config,
        clientConfig,
      });

      expect(result).toContain("id: 54");
    });

    test("if modelNamingDuplicationStrategy is uniquifyWithAppId", async () => {
      config.modelNamingDuplicationStrategy = "uniquifyWithAppId";

      const result = await generate({
        params: {},
        config,
        clientConfig,
      });

      expect(result).toContain("interface Kintone入力項目テストアプリRecord");
      expect(result).toContain(
        "interface Kintone入力項目テストアプリRecordApp55"
      );
    });
  });
});

const actual = `
/* tslint:disable */
/* eslint-disable */
/**
 * This file is auto generated by ${p.name} version ${p.version}.
 * Don\`t edit this file manually.
 * @see ${p.homepage}
 */
import { Record } from "@kintone/rest-api-client/lib/client/types";
import { Calc, Category, CheckBox, CreatedTime, Creator, Date, DateTime, Dropdown, File, GroupSelect, ID, Link, Modifier, MultiLineText, MultiSelect, Number, OrganizationSelect, RadioButton, RecordNumber, Revision, RichText, SingleLineText, Status, StatusAssignee, Subtable, Time, UpdatedTime, UserSelect } from "@kintone/rest-api-client/lib/KintoneFields/types/field";
/**
* KintoneApp54Record
* 入力項目テストアプリ
* id: 54
* revision: 4
* @see ${dummyBaseUrl}/k/54/
*/
export interface KintoneApp54Record extends Record {
    /**
    * ID
    * @type ID
    */
    "__ID__": ID;
    /**
    * Revision
    * @type Revision
    */
    "__REVISION__": Revision;
    /**
    * カテゴリー
    * @type Category
    */
    "カテゴリー": Category;
    /**
    * グループ選択
    * @type GroupSelect
    */
    "グループ選択": GroupSelect;
    /**
    * ステータス
    * @type Status
    */
    "ステータス": Status;
    /**
    * チェックボックス
    * @type CheckBox
    */
    "チェックボックス": CheckBox;
    /**
    * テーブル
    * @type Subtable
    */
    "テーブル": Subtable<{
        /**
        * 文字列 (1行)
        * 文字列__1行__Table
        * @type SingleLineText
        */
        "文字列__1行__Table": SingleLineText;
    }>;
    /**
    * ドロップダウン
    * @type Dropdown
    */
    "ドロップダウン": Dropdown;
    /**
    * ユーザー選択
    * @type UserSelect
    */
    "ユーザー選択": UserSelect;
    /**
    * ラジオボタン
    * @type RadioButton
    */
    "ラジオボタン": RadioButton;
    /**
    * リッチエディター
    * @type RichText
    */
    "リッチエディター": RichText;
    /**
    * リンク
    * @type Link
    */
    "リンク": Link;
    /**
    * ルックアップ
    * @type Number
    */
    "ルックアップ": Number;
    /**
    * レコード番号
    * @type RecordNumber
    */
    "レコード番号": RecordNumber;
    /**
    * 作成日時
    * @type CreatedTime
    */
    "作成日時": CreatedTime;
    /**
    * 作成者
    * @type Creator
    */
    "作成者": Creator;
    /**
    * 作業者
    * @type StatusAssignee
    */
    "作業者": StatusAssignee;
    /**
    * 数値
    * @type Number
    */
    "数値": Number;
    /**
    * 文字列 (1行)
    * 文字列__1行_
    * @type SingleLineText
    */
    "文字列__1行_": SingleLineText;
    /**
    * 文字列 (複数行)
    * 文字列__複数行_
    * @type MultiLineText
    */
    "文字列__複数行_": MultiLineText;
    /**
    * 日付
    * @type Date
    */
    "日付": Date;
    /**
    * 日時
    * @type DateTime
    */
    "日時": DateTime;
    /**
    * 時刻
    * @type Time
    */
    "時刻": Time;
    /**
    * 更新日時
    * @type UpdatedTime
    */
    "更新日時": UpdatedTime;
    /**
    * 更新者
    * @type Modifier
    */
    "更新者": Modifier;
    /**
    * 添付ファイル
    * @type File
    */
    "添付ファイル": File;
    /**
    * 組織選択
    * @type OrganizationSelect
    */
    "組織選択": OrganizationSelect;
    /**
    * 複数選択
    * @type MultiSelect
    */
    "複数選択": MultiSelect;
    /**
    * 計算
    * @type Calc
    */
    "計算": Calc;
}
`.trimStart();
