import ts, { addSyntheticLeadingComment, factory as f } from "typescript";
import p from "../../package.json";

const unescape = (s: string) => {
  return s.replace(/\\u([a-fA-F0-9]{4})/g, (_, g) => {
    return String.fromCharCode(parseInt(g, 16));
  });
};

export const stringer = (nodes: Array<ts.Node>) => {
  const sourceFile = ts.createSourceFile("", "", ts.ScriptTarget.Latest);
  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });

  // https://github.com/microsoft/TypeScript/issues/36174
  return unescape(
    printer.printList(
      ts.ListFormat.MultiLine,
      f.createNodeArray(nodes),
      sourceFile
    )
  );
};

export const sanitizeInterfaceName = (raw: string) => {
  const prefix = "$";
  const cleaned = raw.replace(/\s/gs, "").replace(/[!-#%-/:-@[-^`{-~]/gs, "_");
  if (!cleaned) {
    return prefix;
  } else if (/^\d/.test(cleaned)) {
    return `${prefix}${cleaned}`;
  } else {
    return cleaned;
  }
};

export const createHeaderComment = () => {
  return [
    f.createJsxText("/* tslint:disable */"),
    f.createJsxText("/* eslint-disable */"),
    f.createJSDocComment(
      [
        `This file is auto generated by ${p.name} version ${p.version}.`,
        "Don`t edit this file manually.",
      ].join("\n"),
      [f.createJSDocSeeTag(undefined, undefined, p.homepage)]
    ),
  ];
};

export const withJSDocComments = <T extends ts.Node>(
  node: T,
  comments: Array<string>
) => {
  return addSyntheticLeadingComment(
    node,
    ts.SyntaxKind.MultiLineCommentTrivia,
    [...["", ...new Set(comments)].map((c) => `* ${c}`), ""].join("\n"),
    true
  );
};
